{"hiddenAt":"16.02.2014","waypoint":"OC10808","coordinates":"E 009° 21.888' N 47° 43.444'","link":"https://www.opencaching.de/viewcache.php?wp=OC10808","description":"      Die folgenden zwei Abschnitte (Bug und Programmiersprachen) sind nicht zur Lösung der Aufgabe erforderlich. Sie sind rein informativer Natur.       Bug   Hinter dem Begriff \"Bug\" verbirgt sich im allgemeinen, ist man ein paar englischen Vokabeln mächtig, ein Käfer. Beim Geocaching gibt es die TBs, also Travelbugs und Begriffsvarianten wie \"Buggy\" trifft man zum einen bei den sehr praktischen Kleinkinderbeförderungsfahrzeugen, die zusammengeklappt aussehen, wie ein Käfer, der sich vor einem Feind tot stellt, wie auch bei einigen offroad Spezialfahrzeugen, die in ihrem Aussehen einem großen, dicken Käfer gleichen.   Auch in der Informationstechnologie ist der Begriff Bug und Buggy bekannt. Hier findet der Begriff Verwendung für einen Fehler im Programmtext einer Software. Strotzt ein Programm nur so vor Programmierfehlern, so wird es \"ziemlich Buggy\" genannt. Woher kommt diese Bezeichnung?   Fälschlicherweise wird immer wieder behauptet, dass der Begriff Ende der 40er Jahre des vergangenen Jahrhunderts, bei der Suche nach einem Funktionsfehler im Computer Mark II Aiken Relay Calculator entstanden sei. Nachdem an einem Relais eine tote Motte entfernt wurde war diese Fehlfunktion behoben und der ausführende Techniker schrieb in sein Notizbuch \"First actual case of bug being found\". Dieser Satz weist aber darauf hin, dass der Begriff Bug bereits ein gebräuchlicher Begriff für eine Störung bzw. einen Fehler war. Denn tatsächlich wurde der Begriff Bug in der Telefontechnik geprägt. Das Knacksen und Rauschen bei der Übertragung von Ton wurde darauf zurück geführt, dass kleine Käfer an den Leitungen knabbern würden. Näheres dazu kann gerne auf Wikipedia nachgelesen werden.   Die Chance, dass ein Softwareprogramm komplett fehlerfrei ist, tendiert normalerweise gegen Null. Der Grund dafür ist, dass ein Programmierer, egal wie gut er sein Handwerk beherrscht, seltenst in der Lage ist, beim Erstellen eines Programms zu wissen, wer, zu welchem Zweck, in welcher Umgebung, mit welchem Wissen seine Software später verwenden wird. Einige Dinge sind ihm, hat er ausreichend Erfahrung und testet er ausführlich, bestimmt bekannt. Beispielsweise, dass Anwender die verschiedensten Zeichen und Sonderzeichen in Eingabefelder tippen, die z.B. für ein ganz normales Datum vorgesehen sind. Solche Dinge lassen sich leicht überprüfen und abfangen. Schwieriger wird es bei Feldern, über die Personennamen erfasst werden. In der weiteren Verarbeitung muss darauf geachtet werden, dass hier bis zu asiatischen Schriftzeichen alles eingegeben wird und das Programm damit klar kommen muss. Zudem kommen mit jeder neuen Betriebssystem-Version Veränderungen, mit denen auch der ausgefuchsteste Programmierer nicht rechnet. Somit gilt: Umso mehr ein Programm kann, umso komplexer es wird, desto größer ist die Chance, dass Bugs darin enthalten sind. Das betrifft nicht nur Anwendungssoftware. Auch Betriebssysteme sind davon betroffen. Jedes Update, dass für ein Betriebssystem Monat für Monat eingespielt werden muss, beseitigt einige Bugs und bringt aber bestimmt fast so viele neue mit sich, die später dann wieder korrigiert werden müssen. Solche Bugs finden sich aber nicht nur in Software. Auch die Hardware ist nicht frei davon. Einer der bekanntesten Hardware Bugs hatte der 1994 erschienene Pentium Prozessor von Intel®. Dieser lieferte bei bestimmten Gleitkommadivisionen falsche Ergebnisse.   Nun kommen wir zu dem Begriff Debugging. Um das geht's nämlich bei diesem Cache. So wird der Vorgang bezeichnet, in dem ein Programm von seinen Fehlern befreit wird. Dazu wird das Programm Schritt für Schritt durchgegangen, geprüft, welche Variablen welche Werte enthalten und es wird abgeglichen, was wie geschieht und was wie geschehen sollte. Auf diese Weise können effektiv Fehler gefunden und beseitigt werden. Mehr dazu weiter unten.Programmiersprachen   Hier nun noch ein kurzer Exkurs zu Programmiersprachen. Die Ersten Großrechner/Computer hatten keine Tastaturen um Programme einzugeben. Sie wurden mit gelochten Pappkarten, den Lochkarten, gefüttert, die, je nachdem, wo welche Löcher gestanzt waren, so die Information in Maschinensprache dem Rechengerät mitgeteilt haben, was er zu tun hat. Die Fehleranfälligkeit war hier enorm und wenn mal ein Kästchen Lochkarten runter fiel, dauerte es Stunden, diese wieder in die korrekte Reihenfolge zu bekommen. Der Bildschirm und die Tastatur wurde erfunden und die Programmiersprache \"Assembler\", von der es für jeden Prozessor eine eigene gab, wurde durch Metasprachen ersetzt. Diese glichen erst mal den Lochkarten. Beispielsweise verlangte die Programmiersprache COBOL die exakte Position in Zeile und Spalte der eingegebenen Befehle. Eben wie auf einer Lochkarte. Programmiersprachen der 2. Generation (z.B. C, C++, Pascal, Delphi, ...) sind Heute Standard und deren Befehle können nun in einer \"von Menschen lesbaren\" Sprache eingegeben werden. Sie werden dann von einem sogenannten \"Compiler\" in die Maschinensprache übersetzt, die der jeweilige Prozessor verstehen kann. Die nächste Generation der Programmierung funktioniert über graphische Elemente. Je nach Umfang werden Bausteine zur Verfügung gestellt, die nach gewünschter Logik aneinander gehängt werden. Über Parameter können diese Bausteine dann feinjustiert werden. Dieses \"Bild\" wird dann am Ende wieder in Maschinensprache übersetzt und kann ausgeführt werden. Beispiele für eine solche Sprache findet man z.B. bei der Programmierung von LEGO® Robotern. Nun haben wir zwei Ebenen, in denen Bugs entstehen können. Zum einen kann der Programmierer Fehler einbauen, zum anderen kann der Compiler, der die Metasprache in Maschinensprache übersetzt fehlerhaft sein. Eine weitere Variante sind die Interpreter Programmiersprachen. Als berühmteste Vertreter soll hier BASIC erwähnt werden. Diese Sprache ist relativ leicht zu erlernen und funktioniert so, dass die Programmzeilen Zeile für Zeile an einen sogenannten Interpreter übergeben werden, der sie zur Laufzeit, also zu dem Zeitpunkt, wo das Programm ausgeführt wird, in Maschinencode übersetzt und ausführt. Das hat Vor- und Nachteile.Vorteile sind:      Einfache ProgrammierungEinfaches DebuggingQuelltextkorrekturen während des Debugging möglichBetriebssystem-Plattform übergreifender Einsatz möglich...Nachteile sind:Langsame AusführungszeitenEine Laufzeitumgebung muss mitlaufen und verfügbar seinDer Quellcode kann von Jedermann eingesehen und verändert werden...   Natürlich gibt es noch einige weitere Spielarten. Beispielsweise werden Programme der Programmiersprache JAVA® in eine Art Meta-Code übersetzt, damit sie für den Menschen nicht lesbar sind (Urheberrecht, etc.). Trotzdem ist diese Metasprache noch zu interpretieren, damit sie auf möglichst vielen Plattformen laufen kann. Das hat aber den Nachteil, dass eine Fehlerquelle hinzu kommt und das Ganze ziemlich langsam wird... aber das sind wir ja von JAVA® schon gewohnt :)Der Cache   Vorab Info: Wie bei Mysteries üblich, liegt dieser Cache nicht an den oben genannten Koordinaten. Die Zielkoordinaten befinden sich in unmittelbarer Nähe einer Stelle mit atemberaubendem Blick auf den Bodensee und die Alpen. Das Besondere ist, dass es dort trotzdem so gut wie keine Muggels gibt.      Der Behälter ist zwar groß, trotzdem ist er für TBs und Tauschobjekte nicht geeignet. Aus diesem Grund habe ich am Fuße des Baumes an dem er befestigt ist, einen zweiten Behälter unter einem Stein versteckt. Dieser ist für TBs und Tauschobjekte gedacht.    Dieser Cache soll nun demonstrieren, welche Auswirkungen ein kleiner Fehler in einem Programm haben kann. Ich stufe den Cache auf D4 ein, obwohl er für Manchen einem D5 gleicht und ihn Andere wiederum vermutlich als D1 bewerten würden. Je nach Programmiererfahrung. Es gibt nun zwei Möglichkeiten, die Aufgabe zu lösen:   1.) per Microsoft® Excel®   2.) per JavaScript   Bequemer ist die Excel® Variante, da es hier die Möglichkeit des schrittweise Durchgehens des Quellcodes und Überwachen der Variablen gibt, wie weiter oben beschrieben. Wer aber kein MS-Office® bei sich installiert hat, kann auf Variante 2 zurückgreifen, die weiter unten beschrieben wird.Variante 1: MS Excel® und VBA:   Ich habe Microsoft® Excel® ausgesucht, weil ich denke, dass dieses weit verbreitet und großflächig zur Verfügung steht, auch für MAC® User. Excel® bietet außerdem eine kleine Programmierumgebung für VBA (Visual Basic for applications). VBA hat zudem den Vorteil, dass es leicht verständlich ist und man sich relativ schnell darin einarbeiten kann. Da bestimmt nicht alle Programmieren und somit nicht über eine komplette Programmierumgebung verfügen können, erscheint mir diese Variante am praktikabelsten.   Für Alle, die sich mit VBA bisher noch nicht beschäftigt haben, hier eine Kurzbeschreibung der in diesem Programm eingesetzten Befehle/Elemente:1.) Verwendete Datentypen:   Integer: Ganzzahl, positiv oder negativBoolean: Binärwert, kann WAHR oder FALSCH annehmenString: Zeichenfolge, kann fast alle Zeichen der ASCII Tabelle enthalten. Z.B. die Zeichenfolge \"123\" wird nicht als Zahl interpretiert sondern als Text.2.) Verwendete Zeichen und Operatoren:   \" ' \": (einfaches Hochkomma) Kein Operator. Dieses Zeichen markiert den Beginn eines Kommentares. Ab hier ignoriert der Interpreter, was da steht. Kommentare sollen die Lesbarkeit eines Programmes für Programmierer verbessern. Sie geben Hinweise, was an betreffender Stelle gemacht wird.\"_\": Ermöglicht einen Zeilenumbruch, wo syntaktisch keiner sein darf. So wird die Lesbarkeit verbessert.\"Dim\": Deklariert eine Variable. Der Wert der Variablen kann sich während des Programmablaufs verändern.\"Const\": Deklariert eine Konstante. Der zugewiesene Wert kann nicht geändert werden.\"=\": Je nach Position im Quellcode wird hiermit ein Wert einer Variablen zugewiesen oder zwei Werte/Variablen miteinander verglichen.\"&\": Setzt zwei Zeichenfolgen zu einer zusammen: \"ABC\" & \"DEF\" → \"ABCDEF\".\"> / < / >= / <=\": Vergleiche: größer als / kleiner als / größer oder gleich / kleiner oder gleich.3.) Verwendete Funktionen:   CInt: Wandelt eine Zeichenfolge in eine Ganzzahl um. Z.B. \"123\" zu 123.CStr: Gegenstück zu CInt, wandelt eine Zahl in eine Zeichenfolge um. Z.B. 123 zu \"123\".Mid: Extrahiert eine Teilzeichenfolge (TZF). Parameter 1: Ganze Zeichenfolge, Parameter 2: Startposition der TZF, Parameter 3: Länge der TZF.Asc: Gibt die Position eines Zeichens in der ASCII Tabelle zurück. Z.B. Asc(\"A\") → 65.Chr: Gegenstück zu Asc, Gibt das Zeichen der angegebenen Position aus der ASCII Tabelle zurück. Z.B. Chr(65) → \"A\".If ... Then ... Else ... End if: Wenn ... dann ... sonst ... :)While ... Wend: Schleife: Solange die Bedingung erfüllt ist, wiederhole die Anweisungen bis \"Wend\".For ... To ... Step ... Next: Die For-Schleife wird dann verwendet, wenn von vorne herein bekannt ist, wie oft und in welcher Schrittweite sie durchlaufen wird.Workbooks(...).Sheets(...).Range(...)... : An diesen Stellen werden Veränderungen an der Excel® Tabelle vorgenommen oder Werte eingelesen. Hier geschieht quasi die Ausgabe des Programms.   Voraussetzungen:  Um die Aufgabe in Variante 1 zu lösen, brauchst Du einen PC, auf dem Microsoft® Excel® (mögliche Versionen: 95-2013) installiert ist. In den Sicherheitseinstellungen müssen Makros aktiviert und erlaubt sein. Bitte nicht vergessen, dieses Sicherheitsfeature wieder zu aktivieren, sobald die Aufgabe gelöst ist.Einstieg:  Starte Excel®. Automatisch wird eine leere Arbeitsmappe mit geöffnet. Vergewissere Dich, dass ein Tabellenblatt mit dem Name \"Tabelle1\" vorhanden ist. Speichere diese Datei nun an einen Ort Deiner Wahl mit dem Name \"bug.xls\". Wichtig! Wähle beim Speichern den Dateityp: \"Excel 97-2003 Arbeitsmappe\" aus, auch wenn Du eine neuere Version von Excel® vor Dir hast. Um nun den Visual Basic Editor von Excel® zu öffnen drücke die Tastenkombination [ALT]+[F11]. Im Projektfenster Links oben klicke mit der rechten Maustaste auf \"VBA Projekt (Bug.xls)\", wähle \"Einfügen\" und dann \"Modul\". Kopiere nun den Programm-Quelltext von unten (ab \"Option Explicit\" bis \"End Sub\") in das weiße Hauptfenster. Nun kann es losgehen. Zum Testen kannst Du das Programm einmal laufen lassen (drücke [F5]). In der Tabelle \"Tabelle1\" müsste nun ein schwarz/weißes Muster erscheinen. Die Ausführung des Programms sollte jetzt keine Fehlermeldung erzeugen. Nun kann es an die Fehlersuche gehen. Du kannst das Programm Zeile für Zeile ausführen, indem Du [F8] drückst. Den Inhalt von Variablen kannst Du Dir anzeigen lassen, indem Du mit Rechts auf die Variable klickst und im Kontextmenü auf \"Überwachung hinzufügen\" + [OK] klickst.Was soll dieses Programm tun?   Nun, wie das beim Geocaching so üblich ist, geht es um \"geheime\" Koordinaten. Es hat sich jemand eine Möglichkeit ausgedacht, die Koordinaten seines Verstecks so zu verschlüsseln, dass nicht auf Anhieb klar ist, wie man aus dem Kauderwelsch an Buchstaben und Zahlen Koordinaten nach dem Muster \"N 47° 12.345 E 009° 67.890\" bekommt. Um dieses Kauderwelsch wieder zu entschlüsseln gibt es das folgende Programm. Leider jedoch hat sich an genau einer Stelle ein Bug eingeschlichen...Option Explicit'This program is tested on MS Excel 95, 2000, 2003, 2010, 2013Sub DecryptIt()Dim iAktCol As Integer       'The actual column in the table as IntegerDim iAktLine As Integer      'The actual line to be appliedDim strAktCol As String      'The letter of the actual colDim icnCol As Integer        'Column number in stringDim icnStringPos As Integer  'Position in the string to decryptDim icnLoops As Integer      'Number of same colored fieldsDim strAktCell As String     'Actual cell to be appliedDim boColor As Boolean       'Color black or whiteDim icnI As Integer          'Counter for loopsDim icnNumLen As Integer     'Count of the digits of a numberConst cstrSheetName = \"Tabelle1\"   'Name of the sheet to useConst cstrWorkBookName = \"bug.xls\" 'Name of the workbook to use'String to decrypt (if you use Excel 95 put the following 13 lines'in one line and remvove the unterliners)Const cstrInput = \"Y66XY7XY6X7Y9XY6X8Y7XY10XY7X7Y9X7Y7X7Y7X7Y6X7Y6XYXY7X\" & _                  \"Y7X6Y9XY6XYXY8X6Y6XY7XY7XY9XY7XYXY7XYX7Y6XYXY6X6Y6XYX\" & _                  \"Y9XY7XY8XYXY10XY7XY13XYXY6X6Y6XYXYXYXYXYXY6XYXY9XY12X\" & _                  \"YXY7X7Y8X8Y7X7Y6XYXYXY6XY6X6YXYXYXYXY6XY8X7Y10XY6XY10\" & _                  \"XY7XY7XY9XYXYXYXY6XY6X6YX6Y6XYX9Y8XY11X9Y9XY7XY7XY9XY\" & _                  \"X6Y6XY6XY7XYXY7XY8XY9XY14XY6XY7XY7XY7XYXY7XYXY7XY6XY7\" & _                  \"XY6X7Y9XY9XY14XY7X7Y6XY6X7Y7X7Y7X7Y131X9Y6X7Y7X7Y7X7Y\" & _                  \"7XY8X7Y10XY8X7Y7X7Y6X8Y6X6Y9XY7XYXY7XYXY7XYXYXY6XY7XY\" & _                  \"8X6Y7XY9XY7XY8XY6X6Y9XY6X6YXY6X6YXY7XY6XY11XY7XYXY7XY\" & _                  \"13XY8XY7XY9XYXYXYXYXYXYXY7XY13XY10XY7X8Y7X7Y9XY7X8Y6X\" & _                  \"YXYXYXYXYXY6X8Y12XY11XY7XY7XY9XY7X7Y6XY9X6Y6XYX6Y6XY9\" & _                  \"XY11XY12XY7XY7XY9XY8XY7XY9XY7XYXY7XYXY7XY10XY13XY7XY7\" & _                  \"XYXY7XY8XY7X9Y6X7Y7X7Y7X7Y11X9Y9XYXY6X7Y7X7Y9XY\"'Special info for decoding the stringConst cstrCodeNegativ = \"X\"        'PixelConst ciSubtrahend = 4             'Special decoder'Some stuff for the position of the resultConst ciStartLine = 2             'Line to start drawingConst cstrStartCol = \"C\"          'Column to start drawing'Set the length of one lineConst ciLineLen = 62              'Length of the drawing'-- End of declaration --'Format the sheetWorkbooks(cstrWorkBookName).Sheets(cstrSheetName).Cells.ColumnWidth = 0.83       '10 pixels column widthWorkbooks(cstrWorkBookName).Sheets(cstrSheetName).Cells.RowHeight = 7.5          '10 pixels row heightWorkbooks(cstrWorkBookName).Sheets(cstrSheetName).Cells.Interior.Pattern = xlNone 'Clear all cells'Init of the variablesiAktLine = ciStartLinestrAktCol = cstrStartColiAktCol = Asc(strAktCol) - 64 '\"A\" has pos 65 in ASCII tableicnCol = 1icnStringPos = 1'Run through the encrypted stringWhile icnStringPos <= Len(cstrInput)     strAktCell = strAktCol & CStr(iAktLine)     boColor = (Mid(cstrInput, icnStringPos, 1) = cstrCodeNegativ)     If icnStringPos < Len(cstrInput) Then         icnNumLen = 0         'Count the digits of a number         While (Asc(Mid(cstrInput, icnStringPos + 1 + icnNumLen, 1)) < 58) And _               (icnStringPos + icnNumLen + 1 < Len(cstrInput))             icnNumLen = icnNumLen + 1         Wend         'Determine the count of actual color fields. Differ between 1 and n         If icnNumLen > 0 Then           'Convert the string into a number. E.g. \"123\" to 123           icnLoops = CInt(Mid(cstrInput, icnStringPos + 1, icnNumLen))           icnLoops = icnLoops - ciSubtrahend           icnStringPos = icnStringPos + icnNumLen + 1         Else           icnLoops = 1           icnStringPos = icnStringPos + 1         End If     Else         icnStringPos = icnStringPos + 1     End If     'Do the drawing     For icnI = 0 To icnLoops Step 1         If boColor Then            'Set it to black            Workbooks(cstrWorkBookName).Sheets(cstrSheetName).Range(strAktCell).Interior.ColorIndex = 1         Else            'Set it to white (no color)            Workbooks(cstrWorkBookName).Sheets(cstrSheetName).Range(strAktCell).Interior.Pattern = xlNone         End If         'Get the next column of the sheet (works only from \"A\" to \"BZ\" but it is enough for this case)         iAktCol = iAktCol + 1         If ((iAktCol Mod 26) = 0) Then strAktCol = Chr(26 + 64) Else strAktCol = Chr((iAktCol Mod 26) + 64)         If iAktCol > 26 Then If iAktCol > 52 Then strAktCol = \"B\" & strAktCol Else strAktCol = \"A\" & strAktCol         icnCol = icnCol + 1         'End of line reached, go to the beginning of the next line         If icnCol > ciLineLen Then             icnCol = 1             iAktLine = iAktLine + 1             strAktCol = cstrStartCol             iAktCol = Asc(cstrStartCol) - 64         End If         'Set the next cell         strAktCell = strAktCol & CStr(iAktLine)     Next icnIWendEnd SubVariante 2: Java Script:   Diese Variante ist eine Alternative, falls MS Excel® nicht verfügbar ist. Es ist lediglich ein Texteditor (z.B. Notepad) und ein Webbrowser erforderlich, der Java Script erlaubt.Vorbereitung:   Öffne einen Texteditor Deiner Wahl (z.B. Notepad).Kopiere den HTML Quellcode (s.u.) in den Editor.Speichere die Datei unter dem Namen \"Bug.htm\" ab.Vergewissere Dich, dass dein Browser Java Script erlaubt. (ggf. am Ende die Sicherheitseinstellung wieder aktivieren!)Mit einem Doppelklick auf die Datei \"Bug.htm\" öffnest Du sie in Deinem Browser und kannst das Ergebnis des Programms betrachten.Versuche das Programm zu verstehen, beseitige den Fehler.Hast Du eine Änderung vorgenommen, speichere die Datei, wechsle zum Browser und aktualisiere die Seite um das Ergebnis zu sehen.Kurze Erläuterung:   \"{ und }\" Markiert Anfang und Ende eines Anweisungsblocks.\"==\" Vergleicht zwei Werte miteinander.\"=\" Weist den wert der rechten Seite der linken zu.\"< / > / <= / >=\" Vergleiche: kleiner / größer / kleiner oder gleich / größer oder gleich.\"++\" Erhöht die Variable um genau 1.\".length\" gibt die Länge der Zeichnfolge zurück.\".concat\" Verknüpft zwei Zeichenfolgen.\"charCodeAt\" Gibt den ASCII Code des übergebenen Zeichens zurück.\"parseInt\" Wandelt eine Zeichenfolge aus Zahlen in eine Ganzzahl (Integer) um\"while / for / if...else\" Siehe Beschreibung bei Variante 1.\"string[X]\" Gibt das Zeichen an Stelle \"X\" einer Zeichenfolge zurück.\"document.write\" Gibt das Ergebnis als HTML Code an den Browser.Was soll dieses Programm tun?   Nun, wie das beim Geocaching so üblich ist, geht es um \"geheime\" Koordinaten. Es hat sich jemand eine Möglichkeit ausgedacht, die Koordinaten seines Verstecks so zu verschlüsseln, dass nicht auf Anhieb klar ist, wie man aus dem Kauderwelsch an Buchstaben und Zahlen Koordinaten nach dem Muster \"N 47° 12.345 E 009° 67.890\" bekommt. Um dieses Kauderwelsch wieder zu entschlüsseln gibt es das folgende Programm. Leider jedoch hat sich an genau einer Stelle ein Bug eingeschlichen...Der Quellcode, der für Variante 2 kopiert werden muss (von <HTML> bis <\/HTML>):<html>  <head>    <title>Bug (GC4YN4P)<\/title>  <\/head>  <body>  <font face=\"Courier New\" size=2>      Geocache Bug (GC4YN4P)<br><b>  <script language=\"JavaScript\" type=\"text/javascript\">    //String to decrypt    var strInput=\"Y66XY7XY6X7Y9XY6X8Y7XY10XY7X7Y9X7Y7X7Y7X7Y6X7Y6XYXY7XY7X6Y9XY6XYXY8X6Y6XY7XY7XY9XY7XYXY7XYX7Y6XYXY6X6Y6XYXY9XY7XY8XYXY10XY7XY13XYXY6X6Y6XYXYXYXYXYXY6XYXY9XY12XYXY7X7Y8X8Y7X7Y6XYXYXY6XY6X6YXYXYXYXY6XY8X7Y10XY6XY10XY7XY7XY9XYXYXYXY6XY6X6YX6Y6XYX9Y8XY11X9Y9XY7XY7XY9XYX6Y6XY6XY7XYXY7XY8XY9XY14XY6XY7XY7XY7XYXY7XYXY7XY6XY7XY6X7Y9XY9XY14XY7X7Y6XY6X7Y7X7Y7X7Y131X9Y6X7Y7X7Y7X7Y7XY8X7Y10XY8X7Y7X7Y6X8Y6X6Y9XY7XYXY7XYXY7XYXYXY6XY7XY8X6Y7XY9XY7XY8XY6X6Y9XY6X6YXY6X6YXY7XY6XY11XY7XYXY7XY13XY8XY7XY9XYXYXYXYXYXYXY7XY13XY10XY7X8Y7X7Y9XY7X8Y6XYXYXYXYXYXY6X8Y12XY11XY7XY7XY9XY7X7Y6XY9X6Y6XYX6Y6XY9XY11XY12XY7XY7XY9XY8XY7XY9XY7XYXY7XYXY7XY10XY13XY7XY7XYXY7XY8XY7X9Y6X7Y7X7Y7X7Y11X9Y9XYXY6X7Y7X7Y9XY7\";    var iSubtrahend=4;        //Special info for decoding the string    var strCodeNegativ = \"X\"; //Letter for drawing    var iLineLen=63;          //Set the length of one line    var icnI;                 //Counter for loops                            var icnJ;                 //Counter for loops                            var icnCol;               //The actual column as Integer    var boAktColor;           //Color black or white    var icnNumlen;            //Count of the digits of a number    var icnLoops;             //Number of same colored fields    var strNumber;            //a number as string for converting to integer    //-- End of declaration --    //Init of the variables    icnI = 0;    icnCol = 1;    //Run through the encrypted string    while (icnI < strInput.length)    {        if (strInput[icnI] == strCodeNegativ)        {            boAktColor = true;        } else        {            boAktColor = false;        }                if (icnI < strInput.length -1)        {   //Count the digits of a number            icnNumlen = 0;            strNumber = \"\";            while ((strInput.charCodeAt(icnI + 1 + icnNumlen) < 58) && ((icnNumlen + icnI) < strInput.length - 1))            {                strNumber = strNumber.concat(strInput[icnI + 1 + icnNumlen]);                icnNumlen++;            }            //Determine the count of actual color fields. Differ between 1 and n            if (icnNumlen > 0)            {   //Convert the string into a number. E.g. \"123\" to 123                icnLoops =  parseInt(strNumber);                icnLoops = icnLoops - iSubtrahend;                icnI = icnI + icnNumlen + 1;            } else            {                icnLoops = 1;                icnI++;            }        } else        {            icnI++;        }        //Do the drawing        for (icnJ=0; icnJ <= icnLoops; icnJ++)         {            icnCol++;            if (boAktColor == true)            {   //draw a pixel                document.write(\"@\");            } else            {   //Set it to white (blank)                document.write(\"&nbsp;\");            }            if (icnCol == iLineLen)            {   //End of line reached, go to the beginning of the next line                document.write(\"<br>\");                icnCol=1;            }        }    }<\/script><\/font><\/b><\/body><\/html>© rolX, Opencaching.de, CC BY-NC-ND, Stand: 07.05.2018;alle Logeinträge © jeweiliger Autor","tips":"Mhz Eägfry: Qre Oht fgrpxg avpug vz QrxynengvbafgrvyMhz Pnpur: Qre xüemrfgr Jrt vfg avpug vzzre qre Orfgr :-)","caseType":"normal","difficulty":4,"condition":"ok","name":"Bug von rolX","cacheType":"Rätselcache","terrain":2,"logs":["gfunda / 01.07.2014 / gefundenEin klassischer Fall von Fehleinschätzung ! Der erste Gedanke nach dem Lesen des Listings war: So ein Sch... ,hier muss man Informatik und womöglich noch Entomologie studierthaben, um auf einen grünen Zweig zu kommen ! Dann aber das geile Gefühl, wenn man auch als Laie plötzlich die Lösungvor sich liegen hat !!! ... und genau das macht einen guten Mystery Cache aus.   VDfdC von gfunda ! Logeintrag bei GC und OC","oneirod75 / 11.04.2014 / gefundenGemeinsam unterwegs mit woge63 (GC) konnten wir am Späten Abend auch dieses Döschen seinem Versteck entlocken. Das Rätsel konnte ich nur mit reichlich Unterstützung von woge63 lösen. Danke & Grußoneirod75","KoiMuggele / 28.02.2014 17:00 / gefundenNa wenn das keine Herausforderung war... Kurz nach dem Publish vertiefte ich mich in die Materie und der Code ließ mir schon fast graue Haare wachsen - kein Bug weit und breit. Und trotzdem erscheinen statt Koordinaten nur Gebilde, die ich aufgrund meiner bisherigen Erfahrungen als Ameisenkrieg bezeichnen würde . Irgendwann sprang der fiese kleine Fehler mir dann aber entgegen und das Ziel meiner Mühen lag vor mir.Vielen Dank für das Rätsel der etwas anderen Art, das lag genau auf meiner Linie! Leider nicht auf meiner Linie lag das Final, deswegen konnte ich leider erst Tage nach der Lösung (und nach inzwischen erfolgtem FTF) nach dem offline-Bug suchen. Auch hier war der direkte Weg nicht unbedingt der Beste, aber ein echter Cacher lässt sich von sowas nicht abhalten .Das schön gemachte Final hatte ich in der Form auch noch nie, vielen Dank dafür! Ob der Bonus-Behälter allerdings lange trocken bleibt wage ich zu bezweifeln, auch wenn Stracciatella eine meiner Lieblingssorten ist...","Die Steinschnüffler / 25.02.2014 / gefunden.....immer gut wenn man von beiden Plattformen bei neuen Caches informiert wirdSapperlott......was für ein \"Bug\"............Den Cache gleich sehr interessant gefunden und sofort mal ans debuggen gemacht....uuiiiiii......nicht gleich fündig geworden und erstmal infolge Zeitmangels wieder auf Eis gelegt............ ......gestern haben wir uns der Sache dann nochmal angenommen und sind tief in die Materie eingestigenund so konnten wir dann ein deutliches \"Tschaka\" ausrufen nachdem sich die Pixelei in geordnete Formen bringen lies Also ich muss schon sagen dass mir es auch mit Programmmierkenntnissen nicht gleich gelungen ist den Bug zu identifizieren..........Puhhh aber jetzt hats ja geklappt !!!! Wir sagen Danke für das Rätsel und den Cache Viele GrüßeDie Steinschnüffler P.S.: schade dass er nicht zeitgleich mit GC.com puplished wurde .......... ","Die Steinschnüffler / 24.02.2014 / Hinweis........was für ein hässlicher Bug.......GrüßleDie Steinschnüffler"],"descriptionSnippet":"Bug - der Fehler im Programm","status":"kann gesucht werden"}